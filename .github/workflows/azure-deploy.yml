name: Deploy to Azure Container Apps

# Manual deployment only - no automatic triggers on commits
on:
  workflow_dispatch:

# Cancel in-progress deployment if a new one is started
# Important: This prevents multiple simultaneous deployments to Azure
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

env:
  # Azure resource configuration
  RESOURCE_GROUP: RG-GBLI-AI-Risk-Insights
  CONTAINER_APP_NAME: je-tavily-adapter
  CONTAINER_ENV_NAME: je-tavily-env
  LOCATION: westeurope
  
  # Container images
  MAIN_IMAGE: jeconsulting/searxng-docker-tavily-adapter:latest
  REDIS_IMAGE: valkey/valkey:8-alpine
  SEARXNG_IMAGE: searxng/searxng:latest
  
  # Key Vault configuration
  KEY_VAULT_NAME: gbli-risk-insights-kv

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Log in to Azure using service principal credentials from GitHub secrets
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      # Check if Container Apps environment exists, create if needed
      - name: Create Container Apps Environment if needed
        run: |
          # Check if environment exists
          if ! az containerapp env show \
            --name ${{ env.CONTAINER_ENV_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none 2>/dev/null; then
            
            echo "Creating Container Apps environment..."
            az containerapp env create \
              --name ${{ env.CONTAINER_ENV_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }}
          else
            echo "Container Apps environment already exists"
          fi
      
      # Deploy or update the container app with sidecars using CLI commands
      - name: Deploy Container App with Sidecars
        run: |
          # Check if container app exists
          if az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none 2>/dev/null; then
            
            echo "Container app exists - deleting and recreating to update sidecars configuration..."
            az containerapp delete \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --yes
            
            echo "Waiting for deletion to complete..."
            sleep 10
          fi
          
          # Read config.azure.yaml from repository and prepare for secret injection
          echo "Reading config.azure.yaml from repository..."
          CONFIG_YAML_CONTENT=$(cat config.azure.yaml)
          
          echo "Creating container app with main container..."
          echo "Using image: ${{ env.MAIN_IMAGE }}"
          
          # Create the container app with main container
          # Config will be mounted as a secret volume in the update step
          # Using Azure Container Apps valid combination: 0.75 CPU, 1.5GB total
          az containerapp create \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --environment ${{ env.CONTAINER_ENV_NAME }} \
            --image "docker.io/${{ env.MAIN_IMAGE }}" \
            --target-port 8001 \
            --ingress external \
            --cpu 0.5 \
            --memory 1.0Gi \
            --min-replicas 1 \
            --max-replicas 1 \
            --registry-server docker.io \
            --registry-username ${{ secrets.DOCKER_USER }} \
            --registry-password ${{ secrets.DOCKER_PASSWORD }}
          
          echo "Main container created. Now adding sidecars via YAML update..."
          
          # Create YAML with all three containers, secret volume for config, and registry config
          # Config is mounted as a secret volume at the expected paths for both adapter and SearXNG
          # Total: 0.75 CPU, 1.5GB (valid Azure combination)
          cat > /tmp/sidecars.yaml <<EOF
          properties:
            configuration:
              registries:
              - server: docker.io
                username: ${{ secrets.DOCKER_USER }}
                passwordSecretRef: dockerio-password
              secrets:
              - name: dockerio-password
                value: "${{ secrets.DOCKER_PASSWORD }}"
              - name: config-yaml
                value: |
          $(echo "$CONFIG_YAML_CONTENT" | sed 's/^/        /')
            template:
              volumes:
              - name: adapter-config-volume
                storageType: Secret
                secrets:
                - secretRef: config-yaml
                  path: config.yaml
              - name: searxng-config-volume
                storageType: Secret
                secrets:
                - secretRef: config-yaml
                  path: settings.yml
              containers:
              - name: je-tavily-adapter
                image: jeconsulting/searxng-docker-tavily-adapter:latest
                env:
                - name: SEARXNG_URL
                  value: "http://localhost:8080"
                - name: SEARCH_BACKEND
                  value: "google"
                volumeMounts:
                - volumeName: adapter-config-volume
                  mountPath: /srv/searxng-docker
                resources:
                  cpu: 0.50
                  memory: 1.0Gi
              - name: redis
                image: valkey/valkey:8-alpine
                resources:
                  cpu: 0.15
                  memory: 0.25Gi
              - name: searxng
                image: searxng/searxng:latest
                env:
                - name: SEARXNG_BASE_URL
                  value: "http://localhost:8080/"
                - name: BIND_ADDRESS
                  value: "[::]:8080"
                volumeMounts:
                - volumeName: searxng-config-volume
                  mountPath: /etc/searxng
                resources:
                  cpu: 0.10
                  memory: 0.25Gi
              scale:
                minReplicas: 1
                maxReplicas: 1
          EOF
          
          echo "Updating container app with all containers (main + sidecars)..."
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --yaml /tmp/sidecars.yaml
          
          rm -f /tmp/sidecars.yaml
          
          echo "Deployment completed!"
          
          echo "Waiting 30 seconds for containers to start..."
          sleep 30
      
      # Configure Key Vault access and secret references for Google Search API
      - name: Configure Key Vault Secret References
        run: |
          set -euo pipefail
          
          # Assign system-assigned managed identity to container app
          echo "Assigning managed identity to container app..."
          az containerapp identity assign \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --system-assigned \
            >/dev/null
          
          # Get the principal ID of the managed identity
          PRINCIPAL_ID=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "identity.principalId" \
            --output tsv)
          
          if [ -z "$PRINCIPAL_ID" ] || [ "$PRINCIPAL_ID" = "None" ]; then
            echo "Failed to retrieve managed identity principal ID" >&2
            exit 1
          fi
          echo "Managed identity principal ID: $PRINCIPAL_ID"
          
          # Get Key Vault resource ID for RBAC role assignment
          echo "Retrieving Key Vault resource ID..."
          KEYVAULT_ID=$(az keyvault show \
            --name ${{ env.KEY_VAULT_NAME }} \
            --query "id" \
            --output tsv)
          
          if [ -z "$KEYVAULT_ID" ]; then
            echo "ERROR: Failed to retrieve Key Vault resource ID" >&2
            exit 1
          fi
          echo "Key Vault ID: $KEYVAULT_ID"
          
          # Grant Key Vault Secrets User role to the managed identity
          # This role allows the container app to read secret values from Key Vault
          echo "Granting 'Key Vault Secrets User' role to managed identity..."
          
          # Check if role assignment already exists
          EXISTING_ROLE=$(az role assignment list \
            --assignee "$PRINCIPAL_ID" \
            --scope "$KEYVAULT_ID" \
            --role "Key Vault Secrets User" \
            --query "[0].id" \
            --output tsv 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_ROLE" ] && [ "$EXISTING_ROLE" != "None" ]; then
            echo "Role assignment already exists - skipping"
          else
            echo "Creating new role assignment..."
            # Attempt to create the role assignment
            if az role assignment create \
              --role "Key Vault Secrets User" \
              --assignee-object-id "$PRINCIPAL_ID" \
              --assignee-principal-type ServicePrincipal \
              --scope "$KEYVAULT_ID"; then
              echo "Role assignment created successfully"
            else
              echo "ERROR: Failed to create role assignment" >&2
              echo "The managed identity ($PRINCIPAL_ID) must have 'Key Vault Secrets User' role on Key Vault '${{ env.KEY_VAULT_NAME }}'" >&2
              exit 1
            fi
          fi
          
          # Wait for Azure RBAC permissions to propagate across the platform
          # This is critical - without this wait, Key Vault references may fail
          echo "Waiting 30 seconds for Key Vault permissions to propagate..."
          sleep 30
          
          # Construct Key Vault secret reference URIs for Google Search API
          # These URIs point to secrets stored in Azure Key Vault
          GOOGLE_API_KEY_URI="https://${{ env.KEY_VAULT_NAME }}.vault.azure.net/secrets/GoogleCseApiKey"
          GOOGLE_CSE_ID_URI="https://${{ env.KEY_VAULT_NAME }}.vault.azure.net/secrets/GoogleCseId"
          
          echo "Configuring Key Vault secret references..."
          
          # Create container app secrets with Key Vault references
          # Secrets use 'keyvaultref:' syntax to reference Key Vault secrets
          # The system-assigned managed identity is used automatically to access Key Vault
          echo "Creating container app secrets with Key Vault references..."
          az containerapp secret set \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --secrets \
              "google-api-key=keyvaultref:${GOOGLE_API_KEY_URI},identityref:system" \
              "google-cse-id=keyvaultref:${GOOGLE_CSE_ID_URI},identityref:system" \
            >/dev/null
          
          echo "Container app secrets created successfully"
          
          # Update environment variables to reference the secrets
          # Environment variables use 'secretref:' syntax to reference container app secrets
          # --container-name is required for multi-container apps (with sidecars)
          echo "Updating environment variables to reference secrets..."
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --container-name je-tavily-adapter \
            --set-env-vars \
              GOOGLE_API_KEY="secretref:google-api-key" \
              GOOGLE_CSE_ID="secretref:google-cse-id" \
            >/dev/null
          
          echo "Environment variables updated successfully!"
          echo "Key Vault secret references configured successfully!"
      
      # Display the deployed application URL
      - name: Get Application URL
        id: get_url
        run: |
          FQDN=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          echo "fqdn=$FQDN" >> $GITHUB_OUTPUT
          
          echo "=========================================="
          echo "Deployment completed successfully!"
          echo "=========================================="
          echo "Application URL: https://$FQDN"
          echo "Health check: https://$FQDN/health"
          echo "=========================================="
          echo ""
          echo "Test with:"
          echo "curl -X POST https://$FQDN/search -H 'Content-Type: application/json' -d '{\"query\":\"test\"}'"
      
      # Add deployment summary details to the GitHub Actions job summary tab
      - name: Publish Deployment Summary
        run: |
          FQDN="${{ steps.get_url.outputs.fqdn }}"
          
          # Document the live site URLs for quick reference after deployment
          {
            echo "## Deployment Summary"
            echo ""
            echo "- Application URL: https://${FQDN}"
            echo "- Health check: https://${FQDN}/health"
          } >> "$GITHUB_STEP_SUMMARY"
      
      # Wait for application to be fully ready and verify health
      - name: Verify Application Health
        run: |
          FQDN="${{ steps.get_url.outputs.fqdn }}"
          HEALTH_URL="https://$FQDN/health"
          
          echo "=========================================="
          echo "Verifying application health..."
          echo "=========================================="
          echo "Waiting for application to be ready (max 3 minutes)..."
          echo "Health endpoint: $HEALTH_URL"
          
          # Wait up to 3 minutes for the app to be healthy (longer for first startup)
          MAX_ATTEMPTS=36
          ATTEMPT=0
          SLEEP_TIME=5
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Try to call the health endpoint
            HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" "$HEALTH_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check PASSED!"
              echo "Response:"
              cat /tmp/health_response.json
              echo ""
              echo "=========================================="
              echo "üéâ Deployment verified successfully!"
              echo "=========================================="
              echo "Application is healthy and ready to use"
              echo "URL: https://$FQDN"
              exit 0
            else
              echo "‚è≥ Health check returned HTTP $HTTP_CODE, waiting ${SLEEP_TIME}s..."
              sleep $SLEEP_TIME
            fi
          done
          
          # If we get here, health check failed
          echo "=========================================="
          echo "‚ùå Health check FAILED!"
          echo "=========================================="
          echo "Application did not become healthy within 3 minutes"
          echo ""
          echo "Fetching recent logs for debugging..."
          echo "=========================================="
          az containerapp logs show \
            -n ${{ env.CONTAINER_APP_NAME }} \
            -g ${{ env.RESOURCE_GROUP }} \
            --tail 50 || echo "Could not fetch logs"
          echo "=========================================="
          echo ""
          echo "To view full logs, run:"
          echo "az containerapp logs show -n ${{ env.CONTAINER_APP_NAME }} -g ${{ env.RESOURCE_GROUP }} --tail 100 --follow"
          exit 1

