name: Deploy to Azure Container Apps

# Manual deployment only - no automatic triggers on commits
on:
  workflow_dispatch:

env:
  # Azure resource configuration
  RESOURCE_GROUP: RG-GBLI-AI-Risk-Insights
  CONTAINER_APP_NAME: je-tavily-adapter
  CONTAINER_ENV_NAME: je-tavily-env
  LOCATION: westeurope
  
  # Container images
  MAIN_IMAGE: jeconsulting/searxng-docker-tavily-adapter:latest
  REDIS_IMAGE: valkey/valkey:8-alpine
  SEARXNG_IMAGE: searxng/searxng:latest

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Log in to Azure using service principal credentials from GitHub secrets
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      # Check if Container Apps environment exists, create if needed
      - name: Create Container Apps Environment if needed
        run: |
          # Check if environment exists
          if ! az containerapp env show \
            --name ${{ env.CONTAINER_ENV_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none 2>/dev/null; then
            
            echo "Creating Container Apps environment..."
            az containerapp env create \
              --name ${{ env.CONTAINER_ENV_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }}
          else
            echo "Container Apps environment already exists"
          fi
      
      # Deploy or update the container app with sidecars using CLI commands
      - name: Deploy Container App with Sidecars
        run: |
          # Check if container app exists
          if az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --output none 2>/dev/null; then
            
            echo "Container app exists - deleting and recreating to update sidecars configuration..."
            az containerapp delete \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --yes
            
            echo "Waiting for deletion to complete..."
            sleep 10
          fi
          
          # Read config.azure.yaml from repository and prepare for secret injection
          echo "Reading config.azure.yaml from repository..."
          CONFIG_YAML_CONTENT=$(cat config.azure.yaml)
          
          echo "Creating container app with main container..."
          echo "Using image: ${{ env.MAIN_IMAGE }}"
          
          # Create the container app with main container
          # Config will be mounted as a secret volume in the update step
          # Using Azure Container Apps valid combination: 0.75 CPU, 1.5GB total
          az containerapp create \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --environment ${{ env.CONTAINER_ENV_NAME }} \
            --image "docker.io/${{ env.MAIN_IMAGE }}" \
            --target-port 8000 \
            --ingress external \
            --cpu 0.5 \
            --memory 1.0Gi \
            --min-replicas 1 \
            --max-replicas 1 \
            --registry-server docker.io \
            --registry-username ${{ secrets.DOCKER_USER }} \
            --registry-password ${{ secrets.DOCKER_PASSWORD }}
          
          echo "Main container created. Now adding sidecars via YAML update..."
          
          # Create YAML with all three containers, secret volume for config, and registry config
          # Config is mounted as a secret volume at the expected paths for both adapter and SearXNG
          # Total: 0.75 CPU, 1.5GB (valid Azure combination)
          cat > /tmp/sidecars.yaml <<EOF
          properties:
            configuration:
              registries:
              - server: docker.io
                username: ${{ secrets.DOCKER_USER }}
                passwordSecretRef: dockerio-password
              secrets:
              - name: dockerio-password
                value: "${{ secrets.DOCKER_PASSWORD }}"
              - name: config-yaml
                value: |
          $(echo "$CONFIG_YAML_CONTENT" | sed 's/^/        /')
            template:
              volumes:
              - name: adapter-config-volume
                storageType: Secret
                secrets:
                - secretRef: config-yaml
                  path: config.yaml
              - name: searxng-config-volume
                storageType: Secret
                secrets:
                - secretRef: config-yaml
                  path: settings.yml
              containers:
              - name: je-tavily-adapter
                image: jeconsulting/searxng-docker-tavily-adapter:latest
                env:
                - name: SEARXNG_URL
                  value: "http://localhost:8080"
                volumeMounts:
                - volumeName: adapter-config-volume
                  mountPath: /srv/searxng-docker
                resources:
                  cpu: 0.50
                  memory: 1.0Gi
              - name: redis
                image: valkey/valkey:8-alpine
                resources:
                  cpu: 0.15
                  memory: 0.25Gi
              - name: searxng
                image: searxng/searxng:latest
                env:
                - name: SEARXNG_BASE_URL
                  value: "http://localhost:8080/"
                - name: BIND_ADDRESS
                  value: "[::]:8080"
                volumeMounts:
                - volumeName: searxng-config-volume
                  mountPath: /etc/searxng
                resources:
                  cpu: 0.10
                  memory: 0.25Gi
              scale:
                minReplicas: 1
                maxReplicas: 1
          EOF
          
          echo "Updating container app with all containers (main + sidecars)..."
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --yaml /tmp/sidecars.yaml
          
          rm -f /tmp/sidecars.yaml
          
          echo "Deployment completed!"
          
          echo "Waiting 30 seconds for containers to start..."
          sleep 30
      
      # Display the deployed application URL
      - name: Get Application URL
        id: get_url
        run: |
          FQDN=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          echo "fqdn=$FQDN" >> $GITHUB_OUTPUT
          
          echo "=========================================="
          echo "Deployment completed successfully!"
          echo "=========================================="
          echo "Application URL: https://$FQDN"
          echo "Health check: https://$FQDN/health"
          echo "=========================================="
          echo ""
          echo "Test with:"
          echo "curl -X POST https://$FQDN/search -H 'Content-Type: application/json' -d '{\"query\":\"test\"}'"
      
      # Wait for application to be fully ready and verify health
      - name: Verify Application Health
        run: |
          FQDN="${{ steps.get_url.outputs.fqdn }}"
          HEALTH_URL="https://$FQDN/health"
          
          echo "=========================================="
          echo "Verifying application health..."
          echo "=========================================="
          echo "Waiting for application to be ready (max 3 minutes)..."
          echo "Health endpoint: $HEALTH_URL"
          
          # Wait up to 3 minutes for the app to be healthy (longer for first startup)
          MAX_ATTEMPTS=36
          ATTEMPT=0
          SLEEP_TIME=5
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Try to call the health endpoint
            HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" "$HEALTH_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check PASSED!"
              echo "Response:"
              cat /tmp/health_response.json
              echo ""
              echo "=========================================="
              echo "üéâ Deployment verified successfully!"
              echo "=========================================="
              echo "Application is healthy and ready to use"
              echo "URL: https://$FQDN"
              exit 0
            else
              echo "‚è≥ Health check returned HTTP $HTTP_CODE, waiting ${SLEEP_TIME}s..."
              sleep $SLEEP_TIME
            fi
          done
          
          # If we get here, health check failed
          echo "=========================================="
          echo "‚ùå Health check FAILED!"
          echo "=========================================="
          echo "Application did not become healthy within 3 minutes"
          echo ""
          echo "Fetching recent logs for debugging..."
          echo "=========================================="
          az containerapp logs show \
            -n ${{ env.CONTAINER_APP_NAME }} \
            -g ${{ env.RESOURCE_GROUP }} \
            --tail 50 || echo "Could not fetch logs"
          echo "=========================================="
          echo ""
          echo "To view full logs, run:"
          echo "az containerapp logs show -n ${{ env.CONTAINER_APP_NAME }} -g ${{ env.RESOURCE_GROUP }} --tail 100 --follow"
          exit 1

